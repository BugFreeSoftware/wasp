(self.webpackChunkdoc_ops=self.webpackChunkdoc_ops||[]).push([[673],{1871:function(e,t,n){"use strict";var a=n(7294);t.Z=function(e){var t=e.children,n=e.hidden,r=e.className;return a.createElement("div",{role:"tabpanel",hidden:n,className:r},t)}},1137:function(e,t,n){"use strict";n.d(t,{Z:function(){return b}});var a=n(7294),r=n(4179);var o=function(){var e=(0,a.useContext)(r.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},i=n(6010),s="tabItem_1uMI",u="tabItemActive_2DSg";var l=37,c=39;var b=function(e){var t=e.lazy,n=e.block,r=e.defaultValue,b=e.values,m=e.groupId,d=e.className,f=o(),p=f.tabGroupChoices,y=f.setTabGroupChoices,g=(0,a.useState)(r),h=g[0],B=g[1],I=a.Children.toArray(e.children),w=[];if(null!=m){var _=p[m];null!=_&&_!==h&&b.some((function(e){return e.value===_}))&&B(_)}var T=function(e){var t=e.currentTarget,n=w.indexOf(t),a=b[n].value;B(a),null!=m&&(y(m,a),setTimeout((function(){var e,n,a,r,o,i,s,l;(e=t.getBoundingClientRect(),n=e.top,a=e.left,r=e.bottom,o=e.right,i=window,s=i.innerHeight,l=i.innerWidth,n>=0&&o<=l&&r<=s&&a>=0)||(t.scrollIntoView({block:"center",behavior:"smooth"}),t.classList.add(u),setTimeout((function(){return t.classList.remove(u)}),2e3))}),150))},v=function(e){var t,n;switch(e.keyCode){case c:var a=w.indexOf(e.target)+1;n=w[a]||w[0];break;case l:var r=w.indexOf(e.target)-1;n=w[r]||w[w.length-1]}null==(t=n)||t.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},d)},b.map((function(e){var t=e.value,n=e.label;return a.createElement("li",{role:"tab",tabIndex:h===t?0:-1,"aria-selected":h===t,className:(0,i.Z)("tabs__item",s,{"tabs__item--active":h===t}),key:t,ref:function(e){return w.push(e)},onKeyDown:v,onFocus:T,onClick:T},n)}))),t?(0,a.cloneElement)(I.filter((function(e){return e.props.value===h}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},I.map((function(e,t){return(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==h})}))))}},4179:function(e,t,n){"use strict";var a=(0,n(7294).createContext)(void 0);t.Z=a},213:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return b},toc:function(){return m},default:function(){return f}});var a=n(2122),r=n(9756),o=(n(7294),n(3905)),i=n(1137),s=n(1871),u=["components"],l={},c="Structured Data Types",b={unversionedId:"guide/schema/structs",id:"guide/schema/structs",isDocsHomePage:!1,title:"Structured Data Types",description:"The schema tool allows you to define your own structured data types that are composed of",source:"@site/docs/guide/schema/structs.mdx",sourceDirName:"guide/schema",slug:"/guide/schema/structs",permalink:"/wasp/docs/guide/schema/structs",editUrl:"https://github.com/iotaledger/chronicle.rs/tree/main/docs/docs/guide/schema/structs.mdx",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Using the Schema Tool",permalink:"/wasp/docs/guide/schema/usage"},next:{title:"Type Definitions",permalink:"/wasp/docs/guide/schema/typedefs"}},m=[],d={toc:m};function f(e){var t=e.components,n=(0,r.Z)(e,u);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"structured-data-types"},"Structured Data Types"),(0,o.kt)("p",null,"The schema tool allows you to define your own structured data types that are composed of\nthe predefined WasmLib value data types. The tool will generate a struct with named fields\naccording to the definition in schema.json, and also generates code to serialize and\ndeserialize the structure to a byte array, so that it can be saved as a single unit of\ndata, for example in state storage."),(0,o.kt)("p",null,"You can use such structs directly as a type in state storage definitions and the schema\ntool will automatically generate the proxy code to access it properly."),(0,o.kt)("p",null,"For example, let's say you are creating a ",(0,o.kt)("inlineCode",{parentName:"p"},"betting")," smart contract. Then you would want to\nstore information for each bet. The Bet structure could consist of the bet amount and time\nof the bet, the number of the item that was bet on, and the agent ID of the one who placed\nthe bet. And you would keep track of all bets in state storage in an array of Bet structs.\nYou would insert the following into schema.json:"),(0,o.kt)(i.Z,{defaultValue:"json",values:[{label:"schema.json",value:"json"}],mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"json",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "structs": {\n    "Bet": {\n      "amount": "Int64 // bet amount",\n      "time": "Int64 // timestamp of this bet",\n      "number": "Int32 // number of item we bet on",\n      "better": "AgentID // Who placed this bet"\n    }\n  },\n  "state": {\n    "bets": "[]Bet // all bets made in this round"\n  }\n}\n')))),(0,o.kt)("p",null,"The schema tool will generate ",(0,o.kt)("inlineCode",{parentName:"p"},"types.rs")," which contains the following code for the Bet\nstruct:"),(0,o.kt)(i.Z,{defaultValue:"go",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"}],mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"go",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package betting\n\nimport "github.com/iotaledger/wasp/packages/vm/wasmlib"\n\ntype Bet struct {\n    Amount int64             // bet amount\n    Better wasmlib.ScAgentID // Who placed this bet\n    Number int32             // number of item we bet on\n    Time   int64             // timestamp of this bet\n}\n\nfunc NewBetFromBytes(bytes []byte) *Bet {\n    decode := wasmlib.NewBytesDecoder(bytes)\n    data := &Bet{}\n    data.Amount = decode.Int64()\n    data.Better = decode.AgentID()\n    data.Number = decode.Int32()\n    data.Time = decode.Int64()\n    decode.Close()\n    return data\n}\n\nfunc (o *Bet) Bytes() []byte {\n    return wasmlib.NewBytesEncoder().\n        Int64(o.Amount).\n        AgentID(o.Better).\n        Int32(o.Number).\n        Int64(o.Time).\n        Data()\n}\n\ntype ImmutableBet struct {\n    objID int32\n    keyID wasmlib.Key32\n}\n\nfunc (o ImmutableBet) Exists() bool {\n    return wasmlib.Exists(o.objID, o.keyID, wasmlib.TYPE_BYTES)\n}\n\nfunc (o ImmutableBet) Value() *Bet {\n    return NewBetFromBytes(wasmlib.GetBytes(o.objID, o.keyID, wasmlib.TYPE_BYTES))\n}\n\ntype MutableBet struct {\n    objID int32\n    keyID wasmlib.Key32\n}\n\nfunc (o MutableBet) Exists() bool {\n    return wasmlib.Exists(o.objID, o.keyID, wasmlib.TYPE_BYTES)\n}\n\nfunc (o MutableBet) SetValue(value *Bet) {\n    wasmlib.SetBytes(o.objID, o.keyID, wasmlib.TYPE_BYTES, value.Bytes())\n}\n\nfunc (o MutableBet) Value() *Bet {\n    return NewBetFromBytes(wasmlib.GetBytes(o.objID, o.keyID, wasmlib.TYPE_BYTES))\n}\n'))),(0,o.kt)(s.Z,{mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use wasmlib::*;\nuse wasmlib::host::*;\n\npub struct Bet {\n    pub amount: i64,       // bet amount\n    pub better: ScAgentID, // Who placed this bet\n    pub number: i32,       // number of item we bet on\n    pub time:   i64,       // timestamp of this bet\n}\n\nimpl Bet {\n    pub fn from_bytes(bytes: &[u8]) -> Bet {\n        let mut decode = BytesDecoder::new(bytes);\n        Bet {\n            amount: decode.int64(),\n            better: decode.agent_id(),\n            number: decode.int32(),\n            time: decode.int64(),\n        }\n    }\n\n    pub fn to_bytes(&self) -> Vec<u8> {\n        let mut encode = BytesEncoder::new();\n        encode.int64(self.amount);\n        encode.agent_id(&self.better);\n        encode.int32(self.number);\n        encode.int64(self.time);\n        return encode.data();\n    }\n}\n\npub struct ImmutableBet {\n    pub(crate) obj_id: i32,\n    pub(crate) key_id: Key32,\n}\n\nimpl ImmutableBet {\n    pub fn exists(&self) -> bool {\n        exists(self.obj_id, self.key_id, TYPE_BYTES)\n    }\n\n    pub fn value(&self) -> Bet {\n        Bet::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))\n    }\n}\n\npub struct MutableBet {\n    pub(crate) obj_id: i32,\n    pub(crate) key_id: Key32,\n}\n\nimpl MutableBet {\n    pub fn exists(&self) -> bool {\n        exists(self.obj_id, self.key_id, TYPE_BYTES)\n    }\n\n    pub fn set_value(&self, value: &Bet) {\n        set_bytes(self.obj_id, self.key_id, TYPE_BYTES, &value.to_bytes());\n    }\n\n    pub fn value(&self) -> Bet {\n        Bet::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))\n    }\n}\n")))),(0,o.kt)("p",null,"Notice how the generated ImmutableBet and MutableBet proxies use the from_bytes() and\nto_bytes() (de)serialization code to automatically transform byte arrays into Bet structs."),(0,o.kt)("p",null,"The generated code in ",(0,o.kt)("inlineCode",{parentName:"p"},"state.rs")," that implements the state interface is shown here:"),(0,o.kt)(i.Z,{defaultValue:"go",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"}],mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"go",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package betting\n\nimport "github.com/iotaledger/wasp/packages/vm/wasmlib"\n\ntype ArrayOfImmutableBet struct {\n    objID int32\n}\n\nfunc (a ArrayOfImmutableBet) Length() int32 {\n    return wasmlib.GetLength(a.objID)\n}\n\nfunc (a ArrayOfImmutableBet) GetBet(index int32) ImmutableBet {\n    return ImmutableBet{objID: a.objID, keyID: wasmlib.Key32(index)}\n}\n\ntype ImmutableBettingState struct {\n    id int32\n}\n\nfunc (s ImmutableBettingState) Bets() ArrayOfImmutableBet {\n    arrID := wasmlib.GetObjectID(s.id, idxMap[IdxStateBets], wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES)\n    return ArrayOfImmutableBet{objID: arrID}\n}\n\nfunc (s ImmutableBettingState) Owner() wasmlib.ScImmutableAgentID {\n    return wasmlib.NewScImmutableAgentID(s.id, idxMap[IdxStateOwner])\n}\n\ntype ArrayOfMutableBet struct {\n    objID int32\n}\n\nfunc (a ArrayOfMutableBet) Clear() {\n    wasmlib.Clear(a.objID)\n}\n\nfunc (a ArrayOfMutableBet) Length() int32 {\n    return wasmlib.GetLength(a.objID)\n}\n\nfunc (a ArrayOfMutableBet) GetBet(index int32) MutableBet {\n    return MutableBet{objID: a.objID, keyID: wasmlib.Key32(index)}\n}\n\ntype MutableBettingState struct {\n    id int32\n}\n\nfunc (s MutableBettingState) Bets() ArrayOfMutableBet {\n    arrID := wasmlib.GetObjectID(s.id, idxMap[IdxStateBets], wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES)\n    return ArrayOfMutableBet{objID: arrID}\n}\n\nfunc (s MutableBettingState) Owner() wasmlib.ScMutableAgentID {\n    return wasmlib.NewScMutableAgentID(s.id, idxMap[IdxStateOwner])\n}\n'))),(0,o.kt)(s.Z,{mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use wasmlib::*;\nuse wasmlib::host::*;\n\nuse crate::*;\nuse crate::keys::*;\nuse crate::types::*;\n\npub struct ArrayOfImmutableBet {\n    pub(crate) obj_id: i32,\n}\n\nimpl ArrayOfImmutableBet {\n    pub fn length(&self) -> i32 {\n        get_length(self.obj_id)\n    }\n\n    pub fn get_bet(&self, index: i32) -> ImmutableBet {\n        ImmutableBet { obj_id: self.obj_id, key_id: Key32(index) }\n    }\n}\n\n#[derive(Clone, Copy)]\npub struct ImmutableBettingState {\n    pub(crate) id: i32,\n}\n\nimpl ImmutableBettingState {\n    pub fn bets(&self) -> ArrayOfImmutableBet {\n        let arr_id = get_object_id(self.id, idx_map(IDX_STATE_BETS), TYPE_ARRAY | TYPE_BYTES);\n        ArrayOfImmutableBet { obj_id: arr_id }\n    }\n\n    pub fn owner(&self) -> ScImmutableAgentID {\n        ScImmutableAgentID::new(self.id, idx_map(IDX_STATE_OWNER))\n    }\n}\n\npub struct ArrayOfMutableBet {\n    pub(crate) obj_id: i32,\n}\n\nimpl ArrayOfMutableBet {\n    pub fn clear(&self) {\n        clear(self.obj_id);\n    }\n\n    pub fn length(&self) -> i32 {\n        get_length(self.obj_id)\n    }\n\n    pub fn get_bet(&self, index: i32) -> MutableBet {\n        MutableBet { obj_id: self.obj_id, key_id: Key32(index) }\n    }\n}\n\n#[derive(Clone, Copy)]\npub struct MutableBettingState {\n    pub(crate) id: i32,\n}\n\nimpl MutableBettingState {\n    pub fn bets(&self) -> ArrayOfMutableBet {\n        let arr_id = get_object_id(self.id, idx_map(IDX_STATE_BETS), TYPE_ARRAY | TYPE_BYTES);\n        ArrayOfMutableBet { obj_id: arr_id }\n    }\n\n    pub fn owner(&self) -> ScMutableAgentID {\n        ScMutableAgentID::new(self.id, idx_map(IDX_STATE_OWNER))\n    }\n}\n")))),(0,o.kt)("p",null,"The end result is an ImmutableBettingState and MutableBettingState structure that can\ndirectly interface to the state of the betting contract."),(0,o.kt)("p",null,"In the next section we will look at how to make even more complex type definitions."))}f.isMDXComponent=!0},3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),l=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(u.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,u=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=l(n),d=r,f=m["".concat(u,".").concat(d)]||m[d]||b[d]||o;return n?a.createElement(f,i(i({ref:t},c),{},{components:n})):a.createElement(f,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6010:function(e,t,n){"use strict";function a(e){var t,n,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(r&&(r+=" "),r+=n);else for(t in e)e[t]&&(r&&(r+=" "),r+=t);return r}function r(){for(var e,t,n=0,r="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(r&&(r+=" "),r+=t);return r}n.d(t,{Z:function(){return r}})}}]);